
ZZZZone的模板整理
-------

[TOC]

-----

## 黑科技


### 快读

#### 快读1
``` cpp
inline int read() {      int x=0,f=1;char c=getchar();      for(; c<'0'||'9'<c; c=getchar())if(c=='-')f=-1;      for(; '0'<=c&&c<='9'; c=getchar())x=(x<<3)+(x<<1)+c-'0';      return x*f;  }
```
#### 快读2

```c++
namespace fastIO//输入外挂
{
	#define BUF_SIZE 100000
	//fread -> read
	bool IOerror = 0;
	inline char nc() {
		static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
			if(pend == p1) {
				IOerror = 1;
				return -1;
			}
		}
		return *p1++;
	}
	inline bool blank(char ch) {
		return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
	}
	inline void read(int &x) {
		char ch;
		while(blank(ch = nc()));
		if(IOerror)
			return;
		for(x = ch - '0'; (ch = nc()) >= '0' && ch <= '9'; x = x * 10 + ch - '0');
	}
	#undef BUF_SIZE
};
using namespace fastIO;

void Out(int a)//输出外挂
{
    if(a>9)
        Out(a/10);
    putchar(a%10+'0');
}
```

### long * long 取模
#### 1. 快速乘

```c++
long long quickplus(long long  m,long long n,long long k)//返回m*n%k
{
    long long b = 0;
    while (n > 0)
    {
          if (n & 1)
             b = (b+m)%k;
          n = n >> 1 ;
          m = (m+m)%k;
    }
    return b;
}
```

#### 2. 黑科技
>大概意思就是强制转double然后搞一波再转回来。 

```c++
LL mult( LL A, LL B, LL Mo )
{
    LL temp = ( ( LL ) ( ( db ) A*B/Mo+1e-6 ) * Mo );
    return A*B - temp;
}
```

### unique实现 离散化

```c++
for(int i = 1; i <= n; i++) scanf("%d",&a[i]),b[i]=a[i];
sort(b+1,b+n+1);
int l=unique(b+1,b+n+1)-b-1;
fo(int i = 1; i <= n; i++) a[i]=lower_bound(b+1,b+l+1,a[i])-b;
```

### 手动加栈

#### c++
```c++
#pragma comment(linker, "/STACK:102400000,102400000")
// 写在最前面 
```
#### g++

```c++
int size = 256 << 20; // 256MB  
char *p = (char*)malloc(size) + size;  
__asm__("movl %0, %%esp\n" :: "r"(p));

```

## 图论




### 二分图匹配


####  **匈牙利算法**

```c++
/************************************************************
//二分图匹配(匈牙利算法的DFS实现)(邻接矩阵形式) 
//初始化:g[][]两边顶点的划分情况 
//建立g[i][j]表示i->j的有向边就可以了，是左边向右边的匹配 
//g没有边相连则初始化为0
//uN是匹配左边的顶点数，vN是匹配右边的顶点数 
//调用:res=hungary();输出最大匹配数 
//优点:适用于稠密图，DFS找增广路，实现简洁易于理解
//时间复杂度:O(VE) 
*************************************************************/ 


const int MAXN = 510;
int edge[MAXN][MAXN];//邻接矩阵
int linker[MAXN];
bool used[MAXN];

bool dfs(int u){
	for(int v = 1; v <= n; v++){
		if(edge[u][v] && !used[v]){
			used[v] = true;
			if(linker[v] == -1 || dfs(linker[v])){
				linker[v] = u;
				return true;
			}
		}
	}
	return false;
}

int lungary(){
	int res = 0;
	memset(linker, -1, sizeof(linker));
	for(int i = 1; i <= n; i++){
		memset(used, false, sizeof(used));
		if(dfs(i)) res++;
	}
	return res;
}
```

```c++
// 邻接表
vector<int> edge[MAXN+5];
bool used[MAXN+5];
int linker[MAXN+5];

bool dfs(int u){
	used[u] = true;
	for(int i = 0; i < edge[u].size(); i++){
		int v = edge[u][i], w = linker[v];
		if(w == -1 || (!used[w] && dfs(w))){
			linker[u] = v;
			linker[v] = u;
			return true;
		}
	}
	return false;
}

int matching(){
	int res = 0;
	memset(linker, -1, sizeof(linker));
	for(int i = 1; i <= n; i++){
		if(linker[i] == -1){
			memset(used, false, sizeof(used));
			if(dfs(i)) res++;
		}
	}
	return res;
}

```

### KM算法（二分图带权最大/小匹配) 

> 模板参考: 红书 算法与实现
**复杂度:** $O(n^3)$

```c++
/* w是边权， x和y分别是左边点和右边点的顶标
 * pop是一边点的总数量
 * 下标从0开始。
 */
int w[MAXN+5][MAXN+5];
int x[MAXN+5], y[MAXN+5];
int prev_x[MAXN+5], prev_y[MAXN+5], son_y[MAXN+5], slack[MAXN+5], par[MAXN+5];
int lx, ly, pop;
 
 
void adjust(int v){
    son_y[v] = prev_y[v];
    if(prev_x[son_y[v]] != -2) adjust(prev_x[son_y[v]]);
}
 
bool find(int v){
    int i;
    for (i = 0; i < pop; i++){
        if(prev_y[i] == -1){
            if(slack[i] > x[v] + y[i] - w[v][i]){
                slack[i] = x[v] + y[i] - w[v][i];
                par[i] = v;
            }
            if(x[v] + y[i] == w[v][i]){
                prev_y[i] = v;
                if(son_y[i] == -1){
                    adjust(i);
                    return true;
                }
                if(prev_x[son_y[i]] != -1) continue;
                prev_x[son_y[i]] = i;
                if(find(son_y[i])) return true;
            }
        }
    }
    return false;
}
 
int KM(){
    int i, j, m;
    for(i = 0; i < pop; i++){
        son_y[i] = -1;
        y[i] = 0;
    }
    for(i = 0; i < pop; i++){
        x[i] = 0;
        for(j = 0; j < pop; j++) x[i] = max(x[i], w[i][j]);
    }
    bool flag;
    for(i = 0; i < pop; i++){
        for(j = 0; j < pop; j++){
            prev_x[j] = prev_y[j] = -1;
            slack[j] = INF;
        }
        prev_x[i] = -2;
        if(find(i)) continue;
        flag = false;
        while(!flag){
            m = INF;
            for(j = 0; j < pop; j++){
                if(prev_y[j] == -1) m = min(m, slack[j]);
            }
            for(j = 0; j < pop; j++){
                if(prev_x[j] != -1) x[j] -= m;
                if(prev_y[j] != -1) y[j] += m;
                else slack[j] -= m;
            }
            for(j = 0; j < pop; j++){
                if(prev_y[j] == -1 && !slack[j]){
                    prev_y[j] = par[j];
                    if(son_y[j] == -1){
                        adjust(j);
                        flag = true;
                        break;
                    }
                    prev_x[son_y[j]] = j;
                    if(find(son_y[j])){
                        flag = true;
                        break;
                    }
                }
            }
        }
    }
    int ans = 0;
    for(int i = 0; i < pop; i++) ans += w[son_y[i]][i];
    return ans;
}
```


### 最小生成树


#### Kruskal算法 

复杂度$O(M*log(M) )$

```c++
const int MaxN = 20000;

struct EDGE {
	int u, v, w;
	void Make(int x, int y, int t) {
		u = x; v = y; w = t;
	}
}edge[MaxN + 5];
int n, tot, father[MaxN + 5];

int Find(int x)
{
	if (father[x] == x) return x;
	return father[x] = Find(father[x]);
}

void Init()
{
	int a, b, w; tot = 0;
	for (int i = 1; i <= n; i++) father[i] = i;
	for (int i = 1; i <= n * (n - 1) / 2; i++) {
		scanf("%d%d%d", &a, &b, &w);
		edge[++tot].Make(a, b, w);
	}
}

bool cmp(EDGE x, EDGE y) {return x.w < y.w;}

void Solve()
{
	int Mst_ans = 0;
	sort(edge + 1, edge + tot + 1, cmp);
	for (int i = 1; i <= tot; i++) {
		int u = edge[i].u, v = edge[i].v;
		if (Find(u) != Find(v)) {
			father[Find(u)] = v;
			Mst_ans += edge[i].w;
		}
	}
	printf("%d\n", Mst_ans);
}
```

### SCC强连通分量缩点(Strongly Connected Componenet)

#### Kosaraju算法

```c++
vector<int> edge[MAXN+5];  
vector<int> redge[MAXN+5];//反向建边
vector<int> vs;// 时间戳数组
int sccno[MAXN+5];//缩完点后所属的团
bool used[MAXN+5];

void Dfs(int u){
	used[u] = true;
	for(int i = 0; i < edge[u].size(); i++){
		int v = edge[u][i];
		if(!used[v]) Dfs(v);
	}
	vs.push_back(u);
}
void rDfs(int u, int k){
	used[u] = true;
	sccno[u] = k;
	for(int i = 0; i < redge[u].size(); i++){
		int v = redge[u][i];
		if(!used[v]) rDfs(v, k);
	}
}

int scc(){
	memset(used, false, sizeof(used));
	vs.clear();
	for(int i = 1; i <= n; i++) {
		if(!used[i]) Dfs(i);
	}
	memset(used, false, sizeof(used));
	int k = 0;
	for(int i = vs.size() - 1; i >= 0; i--){
		if(!used[vs[i]]) rDfs(vs[i], ++k);
	}
	return k;
}
```

### 无向图的割点和桥

**定理**: 在无向图连通图G的DFS树中，非根节点$u$是割点当且仅当$u$存在一个子节点$v$, 使得$v$及其所有后代都没有反向连回$u$的祖先.
**复杂度**: $O(n+m)$

```c++
vector<PII> edge[MAXN+5];
bool is_cut_p[MAXN+5], is_cut_edge[MAXN+5], vis[MAXN+5];
int pre[MAXN+5], low[MAXN+5]; 
// low[u]是u及其后代能连回的最早的祖先的pre值.
// 外部初始调用 fa是-1
int n, m, dfs_clock;
int maxlen[MAXN+5];

int Dfs(int u, int fa){
	int lowu = pre[u] = ++dfs_clock;
	for(int i = 0; i < edge[u].size(); i++){
		int v = edge[u][i].first;
		int id = edge[u][i].second;
		if(pre[v] == 0){
			int lowv = Dfs(v, u);
			lowu = min(lowu, lowv);
			if(lowv >= pre[u]){ // 割点
				is_cut_p[u] = true;
				if(lowv > pre[u]){ // 割边
					is_cut_edge[id] = true;
				}
			}
		}
		else if(pre[v] < pre[u] && v != fa){
			lowu = min(lowu, pre[v]);
		}
	}
	low[u] = lowu;
	return lowu;
}

```

## 数据结构



### 归并排序

```c++
//参考紫书算法竞赛入门经典 
void merge_sort(int *A, int l, int r, int *T){ //[l, r) 排序. 外部调用区间为[0, n)
	if(r - l > 1){
		int mid = l+(r-l)/2;
		int p = l, q = mid, now = l;
		// 对左右两部分区间分别归并排序
		merge_sort(A, l, mid, T); 
		merge_sort(A, mid, r, T);
		// 合并左右两部分
		while(p < mid || q < r){
			if(q >= r ||  (p < mid && A[p] <= A[q])){
				T[now++] = A[p++];
			}
			else{
				T[now++] = A[q++];
				cnt += mid - p; // cnt记录的是逆序对个数
			}
		}
		for(int i = l; i < r; i++) A[i] = T[i];
	}
}
```

### 并查集

```c++
int Find(int id)
{
    if(id == fa[id]) return id;
    else return fa[id] = Find(fa[id]);
}
void addu(int u, int v)
{
    int x = Find(u);
    int y = Find(v);
    if(x != y)    fa[x] = y;
}
```

### 树状数组(Binary Indexed Tree, BIT)

树状数组可以进行的操作：

1. 单点修改， 区间查询
2. 区间修改， 单点查询

一维：

```c++
const int MAXN = 1e5;

inline int lowbit(int x) {return (x & -x); }

void Add(int p, int value){
	for(int i = p; i <= MAXN; i += lowbit(i))
		presum[i] += value;
}

int getsum(int p){
	int sum = 0;
	for(int i = p; i > 0; i -= lowbit(i))
		sum += presum[i];
	return sum;
}

```
二维：

```c++
inline int lowbit(int x) {return (x & -x); }

void add(int x, int y, int num, int p){
	for(int i = x; i <= MAXN; i += lowbit(i))
		for(int j = y; j <= MAXN; j+= lowbit(j))
			a[i][j][p] += num;
}

int getsum(int x, int y, int p){
	int ans = 0;
	for(int i = x; i > 0; i -= lowbit(i))
		for(int j = y; j > 0; j -= lowbit(j))
			ans += a[i][j][p];
	return ans;
}

```
### RMQ(Range Minimum/Maximum MaxQuery)

#### ST表(Sparse Table)(静态)
一维：

```c++
int mx[MAXN+5][25]; 
int mn[MAXN+5][25];
int Log2[MAXN+5]; 
//预处理O(nlog(n))  查询O(1)
struct RMQ{
	void init(){
		Log2[0] = -1;
		for(int i = 1; i <= n; i++) Log2[i] = Log2[i >> 1] + 1;
		for(int i = 1; i <= n; i++) mx[i][0] = mn[i][0] = num[i];
		for(int j = 1; (1 << j) <= n; j++){
			for(int i = 1; i + (1 << j) - 1 <= n; i++){
				mx[i][j] = max(mx[i][j-1], mx[i+(1<<(j-1))][j-1]);
				mn[i][j] = min(mn[i][j-1], mn[i+(1<<(j-1))][j-1]);
			}
		}
	}
	int query_max(int ql, int qr){
		int k = Log2[qr-ql+1];
		return max(mx[ql][k], mx[qr-(1<<k)+1][k]);
	}// 查询区间[ql, ql+2^k-1] 和 [qr-2^k+1, qr]; 
	int query_min(int ql, int qr){
		int k = Log2[qr-ql+1];
		return min(mn[ql][k], mn[qr-(1<<k)+1][k]);
	}
}rmq;
```

二维：

```c++
struct RMQ_2D{
	void init(){
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= m; j++)
				dpmax[i][j][0][0] = a[i][j];
		Log2[0] = -1;
		for(int i = 1; i <= MAXN; i++) Log2[i] = Log2[i >> 1] + 1;
		for(int i = 0; (1 << i) <= n; i++){
			for(int j = 0; (1 << j) <= m; j++){
				if(i == 0 && j == 0) continue;
				for(int r=1;r+(1<<i)-1<=n;r++){  
					for(int c=1;c+(1<<j)-1<=m;c++){  
						if(i==0)  
							dpmax[r][c][i][j]=max(dpmax[r][c][i][j-1],dpmax[r][c+(1<<(j-1))][i][j-1]);  
						else  
							dpmax[r][c][i][j]=max(dpmax[r][c][i-1][j],dpmax[r+(1<<(i-1))][c][i-1][j]);  
					}  
				}  
			}
		}
	}

	int query_max(int r1, int c1, int r2, int c2){
		int kr = Log2[r2-r1+1];
		int kc = Log2[c2-c1+1];
		int t1=dpmax[r1][c1][kr][kc];  
		int t2=dpmax[r2-(1<<kr)+1][c1][kr][kc];  
		int t3=dpmax[r1][c2-(1<<kc)+1][kr][kc];  
		int t4=dpmax[r2-(1<<kr)+1][c2-(1<<kc)+1][kr][kc];  
		return max(max(t1,t2),max(t3,t4));  
	}

}rmq;
```

#### 基于线段树(动态)
一维：

```c++
// 此模板为查询最小值。 最大值同理修改即可。
// 挑战程序设计竞赛模板   //下标从0开始。
// 预处理O(n)  查询O(log(n))
const int MAXN = 1 << 17;
const int INF_MAX = 1 << 30;

int n, dat[2 * MAXN -1];
 
void init(int n_){ // 初始化n扩大到2的幂次。
	n = 1;
	while(n < n_) n *= 2;
	for(int i = 0; i < 2 * n - 1; i++) dat[i] = INF_MAX;
}

void update(int k, int num){// 向上
	k += n - 1;
	dat[k] = num;
	while(k > 0){
		k = (k-1) / 2;
		dat[k] = min(dat[k*2+1], dat[k*2+2]);
	}
}
// 求[a, b)最值。 k是节点编号。  左闭右开
// 外部调用query(a, b, 0, 0, n);
int query(int a, int b, int k, int l, int r){
	if(r <= a || b <= l) return INF_MAX;
	if(a <= l &&r <= b) return dat[k];
	else{
		int vl = query(a, b, k*2+1, l, (l+r)>>1);
		int vr = query(a, b, k*2+2, (l+r)>>1, r);
		return min(vl, vr);
	}
}

```

### 线段树

```c++
typedef long long LL;
const int MaxN = 1e5 + 5;
LL sum[4 * MaxN];
LL add[4 * MaxN];
int n, m;

void pushup(int rt){	//向上更新
	sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
}

// 初始化		build(1, n, 1);
void build(int l, int r, int rt){
	if(l == r){
		scanf("%lld", &sum[rt]);
		return;
	}
	int mid = (l + r) >> 1;
	build(l, mid, rt << 1);
	build(mid + 1, r, rt << 1 | 1);
	pushup(rt);
}

void pushdown(int rt, int len){  // 核心 不得不往下的时候再下放
	if(add[rt]){
		add[rt << 1] += add[rt];
		add[rt << 1 | 1] += add[rt];
		sum[rt << 1] += (len - (len >> 1)) * add[rt];
		sum[rt << 1 | 1] += (len >> 1) * add[rt];
		add[rt] = 0;
	}
}
//外部调用update(l, r, x, 1, n, 1);
void update(int L, int R, int num, int l, int r, int rt){  // 更新区间
	if(L <= l && R >= r){
		add[rt] += num;
		sum[rt] += (LL)num * (r - l + 1);
		return;
	}
	pushdown(rt, r - l + 1);
	int mid = (l + r) >> 1;
	if(L <= mid) update(L, R, num, l, mid, rt << 1);
	if(R > mid) update(L, R, num, mid + 1, r, rt << 1 | 1);
	pushup(rt);
}
// 外部调用 query(l, r, 1, n, 1));
LL query(int L, int R, int l, int r, int rt){
	if(L <= l && R >= r) return sum[rt];
	pushdown(rt, r - l + 1);
	int mid = (r + l) >> 1;
	LL ret = 0;
	if(L <= mid) ret += query(L, R, l, mid, rt << 1);
	if(R > mid) ret += query(L, R, mid + 1, r, rt << 1 | 1);
	return ret;
}

```

**结构体版本**
**使用结构体和全局变量，方便一次查询多个信息**

```c++
struct SegmentTree{
	/* 外部先调用tree.Build(1, 1, n);
	 * 每一次询问和查询都要更新ql, qr
	 * _min, _minpos是全局变量, 不需要通过函数返回
	 */
	int _min, _minpos; //最小值, 最小值下标
	int ql, qr; // 每一次操作的区间(修改和查询都是)[ql, qr]
	int Min[4*MAXN+5], Minpos[4*MAXN+5], lazy[4*MAXN+5];
	void Build(int o, int L, int R){//初始化, 节点o, 包含的区间是[L, R]
		Min[o] = Minpos[o] = lazy[o] = 0;
		if(L == R){
			Min[o] = b[L];
			Minpos[o] = L;
			return;
		}
		int mid = (L + R) >> 1;
		Build(o << 1, L, mid);
		Build(o << 1 | 1, mid + 1, R);
		push_up(o, L, R);
	}
	void push_down(int o){
		if(lazy[o] != 0){
			lazy[o << 1] += lazy[o];
			lazy[o << 1 | 1] += lazy[o];
			Min[o << 1] += lazy[o];
			Min[o << 1 | 1] += lazy[o];
			lazy[o] = 0;
		}
	}
	void push_up(int o, int L, int R){
		if(Min[o << 1] < Min[o << 1 | 1]) {
			Min[o] = Min[o << 1];
			Minpos[o] = Minpos[o << 1];
		}
		else{
			Min[o] = Min[o << 1 | 1];
			Minpos[o] = Minpos[o << 1 | 1];
		}
	}
	void Update(int o, int L, int R, int val){ // 区间更新
		if(ql <= L && qr >= R){
			lazy[o] += val;
			Min[o] += val;
		}
		else{
			push_down(o);
			int mid = (L + R) >> 1;
			if(ql <= mid) Update(o << 1, L, mid, val);
			if(qr > mid) Update(o << 1 | 1, mid + 1, R, val);
			push_up(o, L, R);
		}
	}
	void Query(int o, int L, int R){ // 查询
		if(ql <= L && qr >= R){
			if(_min > Min[o]){
				_min = Min[o];
				_minpos = Minpos[o];
			}
		}
		else{
			push_down(o);
			int mid = (L + R) >> 1;
			if(ql <= mid) Query(o << 1, L, mid);
			if(qr > mid) Query(o << 1 | 1, mid + 1, R);
		}
	}
}tree;

```
### LCA

```c++
int fa[MaxN], dis[MaxN];
int up[MaxN][20];
vector<int> edge[MaxN];
int n, q;
/* 先调用dfs(root, 1), 在调用lca_init(), 最后lca(u, v) 查询 */
// up[i][j] 表示i点往上2^j的点是谁。
void dfs(int x, int d){
	dis[x] = d;
	for(int i = 0; i < edge[x].size(); i++){
		if(!dis[edge[x][i]]){
			up[edge[x][i]][0] = x;
			dfs(edge[x][i], d + 1);
		}
	}
}
void lca_init(){
	for(int j = 1; (1 << j) <= n; j++)
		for(int i = 1; i <= n; i++)
			up[i][j] = up[up[i][j - 1]][j - 1];
}
int lca(int a, int b){
    if(dis[a] < dis[b]) swap(a, b); // a在下面
    int c = dis[a] - dis[b];
    for(int i = 0; (1 << i) <= n; i++)  // 比如c 是5（101） 那么先走2^0, 再走2^2
    	if(c & (1 << i)) a = up[a][i];
    if(a == b) return a;
    for(int i = 14; i >= 0; i--){
    	if(up[a][i] != up[b][i]){
    		a = up[a][i];
    		b = up[b][i];
		}
	}
	return up[a][0];
}
```

### 树链剖分

```c++
/*  参考例题  BZOJ  1036: (ZJOI2008)树的统计Count */

const int MAXN = 300000;
const int INF = 0x3f3f3f3f;

int siz[MAXN+5], top[MAXN+5], son[MAXN+5], dep[MAXN+5];
int fa[MAXN+5], tid[MAXN+5], rnk[MAXN+5];
/*  siz[i] 以i为根的子树大小
 *  top[i] 当前节点所在链的头结点
 *  son[i] i节点的重儿子
 *  dep[i] 深度
 *  tid[i] 节点dfs序
 *  rnk[i] dfs序第i个点是哪个点
 */

int n, m, cnt;
int w[MAXN+5];
vector<int> edge[MAXN+5];


void Dfs1(int u, int father){
	dep[u] = dep[father] + 1;
	fa[u] = father;
	siz[u] = 1;
	for(int i = 0; i < edge[u].size(); i++){
		int v = edge[u][i];
		if(v != father){
			Dfs1(v, u);
			siz[u] += siz[v];
			if(son[u] == -1 || siz[v] > siz[son[u]]) son[u] = v;
		}
	}
}

void Dfs2(int u, int st){
	cnt++;
	top[u] = st;
	tid[u] = cnt;
	rnk[cnt] = u;
	if(son[u] == -1) return;
	Dfs2(son[u], st); // 重儿子继承重链
	for(int i = 0; i < edge[u].size(); i++){
		int v = edge[u][i];
		if(v != son[u] && v != fa[u]) Dfs2(v, v); // 构造新的重链
	}
}

struct SegmentTree{
	int sum[MAXN+5], Max[MAXN+5];
	int __sum, __max;
	int ql, qr;
	void Build(int o, int L, int R){
		sum[o] = Max[o] = 0;
		if(L == R){
			sum[o] = Max[o] = w[rnk[L]];
			return;
		}
		int mid = (L + R) >> 1;
		Build(o << 1, L, mid);
		Build(o << 1 | 1, mid+1, R);
		push_up(o);
	}
	void push_up(int o){
		sum[o] = sum[o << 1] + sum[o << 1 | 1];
		Max[o] = max(Max[o << 1], Max[o << 1 | 1]);
	}
	void Update(int o, int L, int R, int val){
		if(ql <= L && qr >= R){
			sum[o] = Max[o] = val;
			return;
		}
		int mid = (L + R) >> 1;
		if(ql <= mid) Update(o << 1, L, mid , val);
		if(qr > mid) Update(o << 1 | 1, mid + 1, R, val);
		push_up(o);
	}
	void Query(int o, int L, int R){
		if(ql <= L && qr >= R){
			__max = max(__max, Max[o]);
			__sum += sum[o];
			return;
		}
		int mid = (L + R) >> 1;
		if(ql <= mid) Query(o << 1, L, mid);
		if(qr > mid) Query(o << 1 | 1, mid + 1, R);
	}
}Stree;

void Init(){
	cnt = 0;
	memset(son, -1, sizeof(son));
	scanf("%d", &n);
	for(int i = 1; i < n; i++){
		int u, v;
		scanf("%d %d", &u, &v);
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	for(int i = 1; i <= n; i++) scanf("%d", &w[i]);
	Dfs1(1, 0);
	Dfs2(1, 1);
	Stree.Build(1, 1, n);
}

void Solve(){
	scanf("%d", &m);
	char s[10];
	int x, y;
	for(int i = 1; i <= m; i++){
		scanf("%s", s);
		scanf("%d %d", &x, &y);
		if(s[0] =='C'){ // 单点修改
			Stree.ql = tid[x], Stree.qr = tid[x];
			Stree.Update(1, 1, n, y);
		}
		else if(s[1] == 'M'){  // 两点路径中最大值
			Stree.__max = -INF;
			int fx = top[x], fy = top[y];
			while(fx != fy){// 
				if(dep[fx] >= dep[fy]){
					Stree.ql = tid[fx], Stree.qr = tid[x];
					Stree.Query(1, 1, n);
					x = fa[fx];
				}
				else{
					Stree.ql = tid[fy], Stree.qr = tid[y];
					Stree.Query(1, 1, n);
					y = fa[fy];
				}
				fx = top[x], fy = top[y];
			}
			// 最后跳到同一条链上之后还需要查询一次
			Stree.ql = min(tid[x], tid[y]);
			Stree.qr = max(tid[x], tid[y]);
			Stree.Query(1, 1, n);
			printf("%d\n", Stree.__max);
		}
		else if(s[1] == 'S'){ // 两点路径之和
			Stree.__sum = 0;
			int fx = top[x], fy = top[y];
			while(fx != fy){
				if(dep[fx] >= dep[fy]){
					Stree.ql = tid[fx], Stree.qr = tid[x];
					Stree.Query(1, 1, n);
					x = fa[fx];
				}
				else{
					Stree.ql = tid[fy], Stree.qr = tid[y];
					Stree.Query(1, 1, n);
					y = fa[fy];
				}
				fx = top[x], fy = top[y];
			}
			Stree.ql = min(tid[x], tid[y]);
			Stree.qr = max(tid[x], tid[y]);
			Stree.Query(1, 1, n);
			printf("%d\n", Stree.__sum);
		}
	}
}

int main()
{
	Init();
	Solve();
    return 0;
}

```

### 划分树

在$O(log(n))$复杂度下查询区间第k大。

```c++
const int MaxN = 1e5, Pow = 20;

int n, m, k;
int a[MaxN + 5];
int tree[Pow + 5][MaxN + 5];
int toleft[Pow + 5][MaxN + 5];
int sorted[MaxN + 5];

bool cmp(int x, int y) {return x < y;}


// 初始化区间[l,r]
void Build(int dep, int l, int r) {
	if(l == r) return;
	int mid = (l + r) >> 1;
	int same = mid - l + 1;
	for(int i = l; i <= r; i++) 
		if(tree[dep][i] < sorted[mid]) same--;
	int lpos = l;
	int rpos = mid + 1;
	for(int i = l; i <= r; i++) {
		if(tree[dep][i] < sorted[mid]) {// 小的值直接放到左儿子
			tree[dep + 1][lpos++] = tree[dep][i];
		}
		else if(tree[dep][i] == sorted[mid] && same > 0) { // 左儿子还有空能放相同的数
			tree[dep + 1][lpos++] = tree[dep][i]; same--;
		}
		else tree[dep + 1][rpos++] = tree[dep][i]; // 剩下的大于等于的放到右儿子
		toleft[dep][i] = toleft[dep][l - 1] + lpos - l; // 更新有多少个数放到了左边
	}
	Build(dep + 1, l, mid);
	Build(dep + 1, mid + 1, r);
}

// 询问[ql, qr] 中第k大的数 
// 外部调用query(1, 1, n, l, r, k);
int query(int dep, int L, int R, int ql, int qr, int k) {
	if(ql == qr) return tree[dep][ql];
	int mid = (L + R) >> 1;
	int cnt = toleft[dep][qr] - toleft[dep][ql - 1];
	if(cnt >= k) {
		int newl = L + toleft[dep][ql - 1] - toleft[dep][L - 1];
		int newr = newl + cnt - 1;
		return query(dep + 1, L, mid, newl, newr, k);
	}
	else {
		int newr = qr + toleft[dep][R] - toleft[dep][qr];
		int newl = newr - (qr - ql - cnt);
		return query(dep + 1, mid + 1, R, newl, newr, k - cnt);
	}
}

void Init() {
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		sorted[i] = tree[1][i] = a[i];
	}
	sort(sorted + 1, sorted + n + 1, cmp);
	Build(1, 1, n);
}

```

### 归并树
n个数， m次询问.
查询区间第k大复杂度为$O(nlog(n) + m*log^3 (n) )$.

```c++
int n, m;
int a[MAXN+5], num[MAXN+5];
vector<int> dat[ST_SIZE];

void init(int k, int l, int r){
	if(r - l == 1){
		dat[k].push_back(a[l]);
	}
	else{
		int lch = k * 2 + 1, rch = k * 2 + 2;
		init(lch, l, (l+r)/2);
		init(rch, (l+r)/2, r);
		dat[k].resize(r-l);
		merge(dat[lch].begin(), dat[lch].end(), dat[rch].begin(), dat[rch].end(), dat[k].begin());
		// 利用STL自带的merge函数把两个儿子的数列合并
	}
}

// 计算[ql, qr) 中不超过x的个数
// k是节点的编号, 对应区间[l, r)
int query(int ql, int qr, int x, int k, int l, int r){
	if(qr <= l || r <= ql){//完全不相交
		return 0;
	}
	else if(ql <= l && r <= qr){ // 询问完全包含当前区间
		return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();
	}
	else{
		int lcnt = query(ql, qr, x, k*2+1, l, (l+r)/2);
		int rcnt = query(ql, qr, x, k*2+2, (l+r)/2, r);
		return lcnt + rcnt;
	}
}

int main()
{
	scanf("%d %d", &n, &m);
	for(int i = 0; i < n; i++){
		scanf("%d", &a[i]);
		num[i] = a[i];
	}
	init(0, 0, n);
	sort(num, num + n); // 排好序的数组， 方便二分
	while(m--){
		int l, r, k;
		scanf("%d %d %d", &l, &r, &k);  
		l--; // 查询区间[l, r]第k大， 转化为下标为零开始的区间[l, r)
		int lb = -1, ub = n-1;
		while(ub - lb > 1){ // 二分k大的数进行check
			int mid = (ub + lb) / 2;
			int c = query(l, r, num[mid], 0, 0, n);
			if(c >= k) ub = mid;
			else lb = mid;
		}
		printf("%d\n", num[ub]);
	}
    return 0;
}
```

### Splay(伸展树)

#### 元素插入删除查询

```c++
struct Splay{
	int f[MAXN+5], son[MAXN+5][2], key[MAXN+5], cnt[MAXN+5], siz[MAXN+5];
	int root, sz;
	inline void clear(int x){
		son[x][0] = son[x][1] = key[x] = cnt[x] = siz[x] = f[x] = 0;
	}
	inline int which_son(int x){ //  查询x时f的左儿子还是右儿子
		return son[f[x]][1] == x;
	}
	void push_up(int x){//更新子树的大小
		if(x){
			siz[x] = cnt[x];
			if(son[x][0]) siz[x] += siz[son[x][0]];
			if(son[x][1]) siz[x] += siz[son[x][1]];
		}
	}
	void rotate(int x){// 旋转操作
		// fa父节点、  ffa父节点的父节点  ths表示x是fa的哪个儿子
		int fa = f[x], ffa = f[fa], ths = which_son(x);  
		son[fa][ths] = son[x][ths^1];  
		f[son[fa][ths]] = fa;
		son[x][ths^1] = fa;
		f[fa] = x;
		f[x] = ffa;
		if(ffa) son[ffa][son[ffa][1] == fa] = x;
		push_up(fa); push_up(x);
	}
	void splay(int x, int who){
		for(int fa; (fa = f[x]) != who; rotate(x)){ // 保证双旋
			if(f[fa]){
				if(which_son(x) == which_son(fa)) rotate(fa); // 三点一线先转f
				else rotate(x); // 否则直接转儿子
			}
		}
		if(!who) root = x;
	}
	void insert(int val){ // 插入元素
		if(root == 0){ // 空树的情况
			sz++;
			son[sz][0] = son[sz][1] = f[sz] = 0;
			key[sz] =val; cnt[sz] = siz[sz] = 1;
			root = sz;
			return;
		}
		int now = root, fa = 0;
		while(true){
			if(key[now] == val){ // 之前已经有这个值了
				cnt[now]++;
				push_up(now); push_up(fa);
				splay(now, 0);
				return;
			}
			fa = now;
			now = son[now][key[now] < val];
			if(now == 0){ // 新插入一个值
				sz++;
				f[sz] = fa;
				son[sz][0] = son[sz][1] = 0;
				key[sz] = val; cnt[sz] = siz[sz] = 1;
				son[fa][key[fa] < val] = sz;
				push_up(fa);
				splay(sz, 0);
				return;
			}
		}
	}
	void del(int val){
		int suibian = find(val); //将val旋转到根
		//如果cnt不为1, 直接--
		if(cnt[root] > 1) { cnt[root]--; push_up(root); return; }
		//只有x一个节点了
		if(!son[root][0] && !son[root][1]) {clear(root); root = 0; return; }
		if(!son[root][0]){//只有右儿子
			int faroot = root;
			root = son[root][1];
			f[root] = 0;
			clear(faroot);
			return;
		}
		else if(!son[root][1]){//只有左儿子
			int faroot = root;
			root = son[root][0];
			f[root] = 0;
			clear(faroot);
			return;
		}
		int leftbig = pre(), faroot = root;
		splay(leftbig, 0);
		f[son[faroot][1]] = root;
		son[root][1] = son[faroot][1];
		clear(faroot);
		push_up(root);
		return;
	}
	int find(int val){ //找到val的排名
		int res = 0, now = root;
		while(true){
			if(val < key[now]) now = son[now][0];
			else{
				if(son[now][0]) res += siz[son[now][0]];
				if(val == key[now]) {
					splay(now, 0);
					return res + 1;
				}
				res += cnt[now];
				now = son[now][1];
			}
		}
	}
	int findx(int pos){ //找到排名是pos的值
		int now = root;
		while(true){
			if(son[now][0] && pos <= siz[son[now][0]]) now = son[now][0];
			else{
				int tmp = cnt[now];
				if(son[now][0]) tmp += siz[son[now][0]];
				if(pos <= tmp) break; //<=是因为一个元素可能插入多次
				pos -= tmp;
				now = son[now][1];
			}
		}
		return key[now];
	}
	inline int pre(){
		int now = son[root][0];
		while(son[now][1]) now = son[now][1];
		return now;
	}
	inline int nxt(){
		int now = son[root][1];
		while(son[now][0]) now = son[now][0];
		return now;
	}
}splay;

```

#### 区间反转

```c++
const int MAXN = 1e5;
int a[MAXN+5];

/*
 * f[i]是i的父节点, son[i][]分别代表i的左右儿子
 * key[i]是i的值, cnt[i]是key[i]出现次数, siz[i]是i以及子树的大小
 * root是根, tot是整棵树的大小, root 初始化为1
 * 可实现 在O(Log(n))复杂度下实现区间反转
 * 外部初始化加入两个边界节点1, n + 2 实际节点是2~n+1
 *
	for(int i = 1; i <= n + 2; i++) a[i] = i-1;
	a[1] = a[n+2] = 1 << 30;
	splay.build(1, n + 2, 0);
	splay.root = 1;
 *  修改区间[l, r]  Reverse(l, r)
 *  通过Dfs中序遍历输出最后的顺序
 */

struct Splay{
	int f[MAXN+5], son[MAXN+5][2], key[MAXN+5], cnt[MAXN+5], siz[MAXN+5];
	int rev[MAXN+5];
	int root, tot;
	inline void clear(int x){
		son[x][0] = son[x][1] = key[x] = cnt[x] = siz[x] = f[x] = 0;
	}
	inline int which_son(int x){ //  查询x时f的左儿子还是右儿子
		return son[f[x]][1] == x;
	}
	void push_up(int x){//更新子树的大小
		if(x){
			siz[x] = cnt[x];
			if(son[x][0]) siz[x] += siz[son[x][0]];
			if(son[x][1]) siz[x] += siz[son[x][1]];
		}
	}
	void push_down(int x){
		if(rev[x]){
			swap(son[x][0], son[x][1]);
			rev[son[x][0]] ^= 1;
			rev[son[x][1]] ^= 1;
			rev[x] = 0;
		}
	}
	void rotate(int x){// 旋转操作
		// fa父节点、  ffa父节点的父节点  ths表示x是fa的哪个儿子
		int fa = f[x], ffa = f[fa], ths = which_son(x);  
		son[fa][ths] = son[x][ths^1];  
		f[son[fa][ths]] = fa;
		son[x][ths^1] = fa;
		f[fa] = x;
		f[x] = ffa;
		if(ffa) son[ffa][son[ffa][1] == fa] = x;
		push_up(fa); push_up(x);
	}
	void splay(int x, int who){
		for(int fa; (fa = f[x]) != who ; rotate(x)){ // 保证双旋
			if(f[fa] != who){
				if(which_son(x) == which_son(fa)) rotate(fa); // 三点一线先转fa
				else rotate(x); // 否则直接转儿子
			}
		}
		if(!who) root = x;
	}
	int build(int l, int r, int father){
		if(l > r) return 0;
		int mid = (l + r) >> 1;
		int now = ++tot;
		clear(now);
		f[now] = father;
		cnt[now] = 1;
		key[now] = a[mid];
		son[now][0] = build(l, mid-1, now);
		son[now][1] = build(mid+1, r, now);
		push_up(now);
		return now;
	}
	int findx(int pos){ //找到排名是pos的值
		int now = root;
		while(true){
			push_down(now);
			if(son[now][0] && pos <= siz[son[now][0]]) now = son[now][0];
			else{
				int tmp = cnt[now];
				if(son[now][0]) tmp += siz[son[now][0]];
				if(pos <= tmp) break; //<=是因为一个元素可能插入多次
				pos -= tmp;
				now = son[now][1];
			}
		}
		return now;
	}
	void Reverse(int l, int r){
		/* 1号节点和n+1是边界节点 
		 * 将l-1旋转到根
		 * 将r+1旋转到根右儿子
		 */
		int x1 = findx(l); 
		int x2 = findx(r+2);
		splay(x1, 0);
		splay(x2, x1);
		rev[son[x2][0]] ^= 1;
	}
	inline int Cut(int l, int r){// 将区间[l, r]减下来插到第k位
        int x1 = findx(l);
        int x2 = findx(r+2);
        splay(x1, 0);
        splay(x2, x1);
        int ct = son[x2][0]; // 区间[l, r]
        son[x2][0] = 0;
        push_up(x2); push_up(x1);
        return ct;
    }
   inline void Add_line(int x, int k){ // 将区间x插入第k位后
        int x1 = findx(k+1);
        int x2 = findx(k+2);
        splay(x1, 0);
        splay(x2, x1);
        son[x2][0] = x;
        f[x] = x2;
        push_up(x2); push_up(x1);
    }

	void Dfs(int x){
		push_down(x);
		if(son[x][0]) Dfs(son[x][0]);
		if(key[x] <= tot && key[x] >= 1) printf("%d ", key[x]);
		if(son[x][1]) Dfs(son[x][1]);
	}
}splay;
```

## 数学

### 扩展Gcd

扩展gcd可以求$ax + by = c$的一组解$(x_0, y_0)$。
并且任意一组整数解可以写成$(x_0 + kb' + y_0+ka')$, 其中$a' =\frac{a}{gcd(a,b)}, b'= \frac{b} { gcd(a,b)}$
>当c是gcd(a,b)的倍数时才有解。



```c++
void extgcd(int a, int b, int& d, int& x, int& y){
	if(!b){ d = a; x = 1; y = 0;}
	else{ extgcd(b, a % b, d, y, x); y -= x * ( a / b); }
}	
```


### 素数
#### 筛素数
```c++
//valid[i]表示i是否为素数。
//ans为素数表。
//tot是素数总数。

/* O(NlogN) */
void getPrime(int n, int &tot, int ans[]){
	tot = 0;
	memset(valid, true, sizeof(valid));
	for(int i = 2; i <= n; i++) if(valid[i]){
		if(n/i<i) break; // 防止i*i爆int
		for(int j = i*i; j <= n; j += i) valid[j] = false;
	}
	for(int i = 2; i <= n; i++) if(valid[i]) ans[++tot] = i;
}

/* O(N) */
void getPrime(int n, int &tot, int ans[]){
	memset(valid, true, sizeof(valid));
	for(int i = 2; i <= n; i++){
		if(valid[i]) ans[++tot] = i;
		for(int j = 1; j <= tot && i * ans[j] <= n; j++){
			valid[i*ans[j]] = false;
			if(i%ans[j] == 0) break;
		}
	}
}

```


### 快速幂

```c++
// log(y)复杂度求x^y%mod;
LL fast_pow(LL x, int y){
	LL ans = 1LL;
	while(y != 0){
		if(y & 1) ans = (ans*x) % mod;
		y >>= 1;
		x = (x * x)%mod;
	}
	return ans % mod;
}
```

### 约瑟夫环问题

```c++
int ans = 0;
for(int i = 2; i <= n; i++)
    ans = (ans + k) % i;
ans = (m - k + 1 + ans) % n;
if(ans <= 0)
    ans += n;
```

## 动态规划

### LIS - 最长上升子序列O(NlogN)

```c++
int dp[MAXN+5];

void solve(){
	fill(dp, dp + n, INF);
	for(int i = 0; i < n; i++) {
		*lower_bound(dp, dp + n, a[i]) = a[i];
	}
	printf("%d\n", lower_bound(dp, dp + n, INF) - dp);
}
```

### 计数问题

**将n划分成不超过m组**
> 白书模板


```c++
int dp[MAXN+5][MAXN+5];
int n, m, Mod;
//dp[i][j]表示j的i划分的总数
void solve(){
	dp[0][0] = 1;
	for(int i = 1; i <= m; i++){
		for(int j = 0; j <= n; j++){
			if(j - i >= 0)
				dp[i][j] = (dp[i-1][j] + dp[i][j-i]) % Mod;
			else 
				dp[i][j] = dp[i-1][j];
		}
	}
	printf("%d\n", dp[m][n]);
}
```


## 字符串

### KMP

```c++
/* 原串s， 匹配串t
 * 先在匹配串t上做自匹配。
 * nxt[i]的意思是到当前位置能匹配的最长前缀的下标。
 * p表示当前最大能匹配到的下标是p
 * 1. 最小循环节长度为 len - nxt[len-1]
 */
void Kmp(char s[], char t[], int &cnt)
{
	int p = -1, len1 = strlen(s), len2 = strlen(t);
	nxt[0] = -1;
	for (int i = 1; i < len2; i++) { 
		while (p > -1 && t[p + 1] != t[i]) p = nxt[p];
		if (t[p + 1] == t[i]) p++;
		nxt[i] = p;
	}
	p = -1;
	for (int i = 0; i < len1; i++) {
		while (p > -1 && s[i] != t[p + 1]) p = nxt[p];
		if (s[i] == t[p + 1]) p++;
		if (p == len2 - 1){ // 匹配成功
			// 进行各种操作
			printf("%d\n", i - (len2 - 1)); // 位置
		 	cnt++, p = nxt[p];// 计数
		 }
	}
}
```


### AC自动机

```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;
const int MaxN = 1000005;
const int MaxV = 1000005;

int n;
int nxt[MaxN][30], fail[MaxN], edd[MaxN], root, L;
//nxt记录节点，edd当前字符串结尾个数，fail失配指针。
int mark[MaxN];
char buf[MaxN], s[MaxV];
//裸模板跑873ms    优化的跑了280ms 交的g++   c++TLE

/*
构造失败指针的过程概括起来就一句话：设这个节点上的字母为C，沿着他父亲的失败指针走，直到走到一个节点，他的儿子中也有字母为C的节点。然后把当前节点的失败指针指向那个字母也为C的儿子。如果一直走到了root都没找到，那就把失败指针指向root。
*/

int newnode(){
    for(int i = 0; i < 26; i++) nxt[L][i] = -1; // 节点链接的初始化为-1
    edd[L] = 0;
    mark[L] = 0;
    return L++;
}

void init(){
    L = 0;
    root = newnode();
}

void insert(char buf[], int len){
    int now = root;
    for(int i = 0; i < len; i++){
        if(nxt[now][buf[i] - 'a'] == -1) nxt[now][buf[i] - 'a'] = newnode();
        now = nxt[now][buf[i] - 'a'];
    }
    edd[now]++;
}

void build(){
    queue<int> que;
    for(int i = 0; i < 26; i++){
        if(nxt[root][i] == -1) nxt[root][i] = root;
        else{
            fail[nxt[root][i]] = root;
            que.push(nxt[root][i]);
            //如果有连边，则将节点插入队列，并将fail指针指向root
        }
    }
    while(!que.empty()){
        int now = que.front();
        que.pop();
        for(int i = 0; i < 26; i++){
            //没有连边，将该边指向当前节点fail指针指向的对应的节点。
            if(nxt[now][i] == -1) nxt[now][i] = nxt[fail[now]][i];
            else{
                //有连边，将儿子节点的fail指针指向当前节点fail指针对应的节点。
                fail[nxt[now][i]] = nxt[fail[now]][i];
                que.push(nxt[now][i]);
                //加入队列继续遍历//
            }
        }
    }
}

int query(char buf[], int len){
    int now = root;
    int res = 0;
    for(int i = 0; i < len; i++){
        now = nxt[now][buf[i] - 'a'];
        int temp = now;
        //这里优化访问过的就不再访问
        while(temp != root && mark[temp] == 0){
            res += edd[temp];
            edd[temp] = 0;
            mark[temp] = 1;
            temp = fail[temp];
        }
        /*
        //裸模板:
          while(temp != root){
            res += edd[temp];
            edd[temp] = 0;//模式串在主串中匹配一次就可以了
            temp = fail[temp];
          }
        */
    }
    return res;
}

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        scanf("%d", &n);
        init();
        int Maxlen = 0;
        for(int i = 1; i <= n; i++){
            scanf("%s", buf);
            int len = strlen(buf);
            insert(buf, len);
        }
        scanf("%s", s);
        Maxlen = strlen(s);
        build();
        int tot = query(s, Maxlen);
        printf("%d\n", tot);
    }
    return 0;
}
```

## 几何

### 欧拉几何定理:
 $V+F-E=X(P)$，V是多面体P的顶点个数，F是多面体P的面数，E是多面体P的棱的条数，$X(P)$是多面体P的欧拉示性数。
 
###  二维几何: 点线面
 
**参考刘汝佳算法竞赛入门经典训练指南（蓝书）**

 ```c++
 
const double eps = 1e-10;

struct Point{ // 点
	double x, y;
	Point(double x = 0, double y = 0): x(x), y(y){}
};

typedef Point Vector; // 向量

// 向量+向量=向量,  点+向量=点
Vector operator + (Vector A, Vector B) {return Vector(A.x + B.x, A.y + B.y); }
Vector operator - (Vector A, Vector B) {return Vector(A.x - B.x, A.y - B.y); }

//向量 * / 数 = 向量
Vector operator * (Vector A, double p) {return Vector(A.x * p, A.y * p); }
Vector operator / (Vector A, double p) {return Vector(A.x / p, A.y / p); }

bool operator < (const Point& a, const Point& b){
	return a.x < b.x || (a.x == b.x && a.y < b.y);
}

// 提高精度
int dcmp(double x){
	if(fabs(x) < eps) return 0;
	else return x < 0 ? -1 : 1;
}
bool operator == (const Point& a, const Point& b){
	return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0;
}


//点积
double Dot(Vector A, Vector B) {return A.x * B.x + A.y * B.y;} 
//向量长度
double Length(Vector A) {return sqrt(Dot(A, A)); }
//向量夹角
double Angle(Vector A, Vector B){
	return acos(Dot(A, B) / Length(A) / Length(B));
}

//叉积 Det(a, b)  a 在 b 的左边 < 0, 右边 > 0.  共线=0
double Det(Vector A, Vector B){ return A.x * B.y - A.y * B.x; }
//利用叉积计算三角形有向面积
Vector Area2(Point A, Point B, Point C){ return Det(B-A, C-A); }
// 将向量逆时针旋转rad弧度
Vector Rotate(Vector A, double rad){
	return Vector(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));
}
// 计算向量的单位法线, 即左转90°
Vector Normal(Vector A){
	double L = Length(A);
	return Vector(-A.y/L, A.x/L);
}

/****    点和直线   ******/

// 直线交点  参数方程
Point GetLineIntersection(Point P, Vector v, Point Q, Vector w){
	Vector u = P - Q;
	double t = Det(w, u) / Det(v, w);
	return P + v * t;
}

// 点P到直线AB的距离, 用叉积算(平行四边形面积除以底)
double DistanceToLine(Point P, Point A, Point B){
	Vector v1 = B - A, v2 = P - A;
	return fabs(Det(v1, v2)) / Length(v1);
}

//  点P到线段AB的距离
double DistanceToSegment(Point P, Point A, Point B){
	if(A == B) return Length(P-A);
	Vector v1 = B-A, v2 = P-A, v3 = P-B;
	if(dcmp(Dot(v1, v2)) < 0) return Length(v2);
	else if(dcmp(Dot(v1, v3)) > 0) return Length(v3);
	else return fabs(Det(v1, v2)) / Length(v1);
}

// 点P在直线AB上的投影
Point GetLineProjection(Point P, Point A, Point B){
	Vector v = B - A;
	return A + v * (Dot(v, P-A)/Dot(v, v));
}

// 线段相交
bool OnSegment(Point p, Point a1, Point a2){  // 特殊情况， 相交在端点
	return dcmp(Det(a1-p, a2-p)) == 0 && dcmp(Dot(a1-p, a2-p)) < 0;
}

bool SegmentIntersect(Point a1, Point a2, Point b1, Point b2){ 
	/* 考虑端点的情况
	if(OnSegment(a1, b1, b2) || OnSegment(a2, b1, b2)) return true;
	if(OnSegment(b1, a1, a2) || OnSegment(b2, a1, a2)) return true;
	*/
	// 默认不包括端点
	double c1 = Det(a2-a1, b1-a1), c2 = Det(a2-a1, b2-a1);
	double c3 = Det(b2-b1, a1-b1), c4 = Det(b2-b1, a2-b1);
	return dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;
}


/*****    多边形    *******/

//计算多边形有向面积
double PolygonArea(Point* P, int n){
	double area = 0;
	for(int i = 1; i < n - 1; i++)
		area += Det(P[i] - P[0], P[i+1] - P[0]);
	return area / 2;
}

// 计算凸包
vector<Point> Convexhull(vector<Point>& a){
	vector<Point> ans(2*a.size() + 5);
	sort(a.begin(), a.end());
	a.erase(unique(a.begin(), a.end()), a.end());  
	int m = 0;
	for(int i = 0; i < a.size(); i++){ 
		while(m > 1 && Det(ans[m-1] - ans[m-2], a[i] - ans[m-2]) <= 0) m--;
		ans[m++] = a[i];
	}
	int k = m;
	for(int i = (int)a.size() - 2; i >= 0; i--){
		while(m > k && Det(ans[m-1] - ans[m-2], a[i] - ans[m-2]) <= 0) m--;
		ans[m++] = a[i];
	}
	if(a.size() > 1) m--;
	ans.resize(m);
	return ans;
}	

/************ 圆 **************/

struct Circle{
	Point c;
	double r;
	Circle(Point c = Point(0, 0), double r = 0):c(c), r(r){}
	Point point(double a){
		return Point(c.x + cos(a)*r, c.y + sin(a) * r);
	}
};

//向量极角
double angle(Vector v){ return atan2(v.y, v.x);}

// 求两圆交点
int getCircleCircleIntersection(Circle C1, Circle C2, vector<Point>& sol){
	double d = Length(C1.c - C2.c);
	if(dcmp(d) == 0){
		if(dcmp(C1.r - C2.r) == 0) return -1; // 两圆重合
		return 0; // 不重合的同心圆
	}
	if(dcmp(C1.r + C2.r - d) < 0) return 0; // 相离
	if(dcmp(fabs(C1.r - C2.r) - d) > 0) return 0; // 内含

	double a = angle(C2.c - C1.c);// 向量C1 C2的极角
	double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d));
	Point p1 = C1.point(a-da), p2 = C1.point(a+da);
	sol.push_back(p1);
	if(p1 == p2) return 1;
	sol.push_back(p2);
	return 2;
}

double Inter(Circle x, Circle y){ // 使用余弦定理求两个圆相交部分的弧长
	double d = Length(x.c - y.c);
	double angle1 = acos((x.r * x.r + d * d - y.r * y.r) / (2.0 * x.r * d));
	double angle2 = acos((y.r * y.r + d * d - x.r * x.r) / (2.0 * y.r * d));
	double s = y.r * angle2 * 2 - x.r * angle1 * 2;
	return s;
}


 ```



##C++STL
###  unique（去重）
**需要头文件**： `#include<algorhtm>`
**作用**：“去掉”容器中 ==**相邻**元素==的重复元素（不一定要求数组有序），它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址。

```c++
//用来去掉相邻元素个数后剩余的个数。
// 一般来说先sort排序， 再进行去重。
sz = unique(b + 1,b + n + 1)-(b + 1); // 下标从1开始
sz = unique(a,a + n) - a;  //下标从0开始
```
如果要删去重复元素， 可以erase尾部元素， 或者直接改变大小。

```c++
for (int i = 0;i < n;++i) scanf("%d",&a[i]);  
sort (a, a + n);  
vector<int>v (a, a + n);  
vector<int>::iterator it = unique (v.begin(), v.end() );   //迭代器
v.erase (it, v.end() );//这里就是把后面藏起来的重复元素删除了  
```

**结构体struct使用unique**：
方法和sort排序的cmp一样， 也可是通过结构体的重载`==`号。

```c++
struct Point{
	int x, y;
	bool friend operator == (Point a, Point b){
		if(a.x != b.x) return a.y == b.y;
		return a.x == b.x;
	}
}b[10];
...

int m = unique(b, b + n) - b; // 重载==


//********************
struct Point{
	int x, y;
}b[10];

bool uni(Point a, Point b){
	if(a.x != b.x) return a.y == b.y;
	return a.x == b.x;
}
...

int m = unique(b, b + n, uni) - b;//类似于sort的cmp函数。

```

### reverse
`reverse(beg,end)`将区间[beg,end)内的元素全部逆序；
**所需头文件**`#include<algorithm>`
**复杂度** 线性

只能传入迭代器。

```c++
普通数组：
scanf("%d", &n);
for(int i = 0; i < n; i++) scanf("%d", &a[i]);
sort(a, a + n);
reverse(begin(a), begin(a)+n);
// 这里最好不要使用reverse(begin(a), end(a)); 因为end(a)是数组尾部， 平时acm中我们经常会+5多开一些空间，就无法正确反转了。
for(int i = 0 ; i < n; i++) printf("%d ", a[i]); printf("\n");
//**********  vector
for(int i = 0; i < n; i++) b.push_back(a[i]);
reverse(b.begin(), b.end());
for(int i = 0 ; i < n; i++) printf("%d ", b[i]); printf("\n");

```

### vector
二维vector
**声明**：`vector<vector<int> > ans;`
**添加元素**:

```c++
for(int i = 1; i <= n; i++){
	ans.push_back(vector<int>(0, 0));
	// 先push_back一个空的一维vector
	// vector<int>(x, y) 表示创建一个有x个y的一维数组。
	for(int j = 1; j <= m; j++){
		ans[i].push_back(i*j);
	}
}
```
### rope (块状链表) 
>rope是c++的stl库中的一个叫做可持久化平衡树的结构


**需要头文件**: `#include <ext/rope>`
**需要命名空间**: `using namespace __gnu_cxx;`
**复杂度**: $O(n * \sqrt{(n)})$
**基本操作**:

```c++
#include <cstdio>
#include <ext/rope>
using namespace std;
using namespace __gnu_cxx;
//要用的头文件和命名空间等
rope test;//定义
rope<int> a;
rope<char> s;  
crope t;   // 等价rope<char> t;

test.push_back(x);//在末尾添加x
test.insert(pos,x);//在pos插入x　　
test.erase(pos,x);//从pos开始删除x个
test.copy(pos,len,x);//从pos开始到pos+len为止用x代替
test.replace(pos,x);//从pos开始换成x
test.substr(pos,x);//提取pos开始x个
test.at(x)/[x];//访问第x个元素
```
### next_permutation(下一个全排列）
**需要头文件**: `#include<algorithm>`
**用法**: `next_permutation(arrays,arrays+n);`
**用途**:  长度为n的数组arrays生成下一个全排列。
同理， 相应的有**prev_permutation**（上一个全排列）。 
### lexicographical_compare（字典序比较）
**所需头文件**: `#include<algorithm>`
**用法**: `lexicographical_compare(s1, s2)`
**用途**: 比较s1和s2的字典序， s1比s2小返回true， 反之返回false。

### merge （将两个已排序序列合并成新的排序序列）

函数接口：

 ```c++
 std::merge (first1,last1,first2,last2, first3);
 ```

将有序的序列[first1, last1), [first2, last2)合并后放到first3开始的位置.
复杂度： O(len1 + len2);

**使用样例**：

```c++
// merge algorithm example
#include <iostream>     // std::cout
#include <algorithm>    // std::merge, std::sort
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);

  std::sort (first,first+5);
  std::sort (second,second+5);
  std::merge (first,first+5,second,second+5,v.begin());

  std::cout << "The resulting vector contains:";
  for (std::vector<int>::iterator it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
```
**源码**：

```c++
// 可以cmp ， 也可以重载 < 
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator merge (InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputIterator result)
{
  while (true) {
    if (first1==last1) return std::copy(first2,last2,result);
    if (first2==last2) return std::copy(first1,last1,result);
    *result++ = (*first2<*first1)? *first2++ : *first1++;
  }
}
```

### inplace_merge （将两段排好序的序列归并排序）

函数接口：

```c++
 void inplace_merge (first, middle, last);
```

将两个已排序的序列[first,middle)和[middle,last)合并成单一有序序列. 

**使用样例**：

```c++
#include <iostream>     // std::cout
#include <algorithm>    // std::inplace_merge, std::sort, std::copy
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);
  std::vector<int>::iterator it;

  std::sort (first,first+5);
  std::sort (second,second+5);

  it=std::copy (first, first+5, v.begin());
     std::copy (second,second+5,it);

  std::inplace_merge (v.begin(),v.begin()+5,v.end());

  std::cout << "The resulting vector contains:";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
```

### builtin系列 （GCC）
**__builtin_ffs(x)**：x中最后一个为1的位是从后向前的第几位。
**__builtin_popcount(x)**：x中1的个数。
**__builtin_parity(x)**：x中1的奇偶性。

### *max_element函数找最大元素 / min_element函数找最小元素

- **返回容器中最大值的地址**

```c++
	int a[MAXN+5];
	int pos = min_element(a+l, a+r+1) - a;
```



## Java

### java文件输入输出
```java     Scanner sc = new Scanner(new File("trains.in"));     PrintWriter ex = new PrintWriter(new File("trains.out"));```###  关于BigInteger and BigDecimal的用法
```javaBigInteger b = BigInteger.valueOf(a); //将参数换成指定类型BigInteger abs()  返回大整数的绝对值BigInteger add(BigInteger val) 返回两个大整数的和BigInteger and(BigInteger val)  返回两个大整数的按位与的结果BigInteger andNot(BigInteger val) 返回两个大整数与非的结果BigInteger divide(BigInteger val)  返回两个大整数的商double doubleValue()   返回大整数的double类型的值float floatValue()   返回大整数的float类型的值BigInteger gcd(BigInteger val)  返回大整数的最大公约数int intValue() 返回大整数的整型值long longValue() 返回大整数的long型值BigInteger max(BigInteger val) 返回两个大整数的最大者BigInteger min(BigInteger val) 返回两个大整数的最小者BigInteger mod(BigInteger val) 用当前大整数对val求模BigInteger multiply(BigInteger val) 返回两个大整数的积BigInteger negate() 返回当前大整数的相反数BigInteger not() 返回当前大整数的非BigInteger or(BigInteger val) 返回两个大整数的按位或BigInteger pow(int exponent) 返回当前大整数的exponent次方BigInteger remainder(BigInteger val) 返回当前大整数除以val的余数BigInteger leftShift(int n) 将当前大整数左移n位后返回BigInteger rightShift(int n) 将当前大整数右移n位后返回BigInteger subtract(BigInteger val)返回两个大整数相减的结果byte[] toByteArray(BigInteger val)将大整数转换成二进制反码保存在byte数组中String toString() 将当前大整数转换成十进制的字符串形式BigInteger xor(BigInteger val) 返回两个大整数的异或getLowestSetBit() 返回此 BigInteger 最右端（最低位）1 比特的索引（即从此字节的右端开始到本字节中最右端 1 比特之间的 0 比特的位数）。hashCode() 返回此 BigInteger 的哈希码isProbablePrime(int certainty) 如果此 BigInteger 可能为素数，则返回 true，如果它一定为合数，则返回 falsemodInverse(BigInteger m) 返回其值为 (this-1 mod m) 的 BigInteger。modPow(BigInteger exponent, BigInteger m) 返回其值为 (thisexponent mod m) 的 BigInteger。negate() 返回其值是 (-this) 的 BigIntegernextProbablePrime() 返回大于此 BigInteger 的可能为素数的第一个整数。probablePrime(int bitLength, Random rnd) 返回有可能是素数的、具有指定长度的正 BigIntegersetBit(int n) 返回其值与设置了指定位的此 BigInteger 等效的 BigInteger。signum() 返回此 BigInteger 的正负号函数toByteArray() 返回一个 byte 数组，该数组包含此 BigInteger 的二进制补码表示形式。//double 控制精度double a=1113.141592653;  DecimalFormat formatter1 = newDecimalFormat("#.000000");  System.out.println(formatter1.format(a));  //BigDecimal型数据的小数点控制输出//方法1  BigDecimal bd1=new BigDecimal(b);  DecimalFormat formatter2=new DecimalFormat("#.000000");   System.out.println(formatter2.format(bd1.doubleValue()));  //方法2, BigDecimal中的setScale方法的第一个参数就  //是我们要指定的精度位数,这里我设为6位小数,但记住，如果  //舍入后的结果后面几位小数是0，则会被省略，就是说0没被输出,详见后面的测试  BigDecimal bd2=new BigDecimal(b);System.out.println(bd2.setScale(6,BigDecimal.ROUND_HALF_UP).doubleValue());  //四舍五入```### 一些函数的用法
```java    Math.abs(a); // 取绝对值    Math.max(a, b);    Math.min(a, b);    a.equals(b); // 判断字符串a, b是否相等，相等返回1， 否则返回0    a.compareTo(b); // 比较字符串a,b大小, 相等返回0, 大于返回1, 小于返回-1    m.toString(); // 将m转成字符串输出    Arrays.sort(a); // a是数组名```### java多组读入
```java    Scanner cin = new Scanner(System.in);    while(cin.hasNext()) { // 相当于EOF        int n = cin.nextInt();    }```### java中的sort的用法
```java
//则o1 小于o2，返回-1（负数），相等返回0，01大于02返回1（正数）升序import java.math.*;import java.util.*;public class test{	public static class node { int x;}	private static class cmp1 implements Comparator<node> {		public int compare(node a, node b) {			if(a.x > b.x) return -1;			else if(a.x == b.x) return 0;			else return 1;		}	}	public static void main(String[] args) {		node a[] = new node[10];		for (int i = 0; i <= 9; i++) a[i] = new node();		for (int i = 0; i <= 9; i++) a[i].x = i;		Arrays.sort(a, new cmp1());		for (int i = 0; i <= 9; i++) System.out.print(a[i].x + " ");		System.out.print("\n");		Arrays.sort(a, 0, 10, new cmp1()); // [], from, to - 1, cmp		for (int i = 0; i <= 9; i++) System.out.print(a[i].x + " ");		System.out.print("\n");	}}
```


## 其他

### O(n)求第k小数

```c++
void quickSelect(LL a[], int l, int r, int rank)
{
    int i = l, j = r;
    LL mid = a[(l + r) / 2];
    do {
        while (a[i] < mid) ++i;
        while (a[j] > mid) --j;
        if (i <= j) {
            swap(a[i], a[j]);
            ++i; --j;
        }
    }while (i <= j);
    if (l <= j && rank <= j - l + 1) quickSelect(a, l, j, rank);
    if (i <= r && rank >= i - l + 1) quickSelect(a, i, r, rank - (i - l));
}
 
LL quick_select(LL a[], int n, int k)
{
    quickSelect(a, 1, n, k);
    return a[k];
}
```

### 杜教BM板子推数列

```c++

#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;

ll qpow(ll x,ll y)
{
	ll res=1;
	for(;y;y>>=1,x=x*x%mod)
		if(y&1)res=res*x%mod;
	return res;
}

int n;
namespace xx
{
	const int N=10010;
	ll res[N],base[N],z[N],md[N];

	vector<int>G;
	void mul(ll *a,ll *b,int k)
	{
		for(int i=0; i<k+k; i++)
			z[i]=0;
		for(int i=0; i<k; i++)
			if(a[i])
				for(int j=0; j<k; j++)
					z[i+j]=(z[i+j]+a[i]*b[j])%mod;
		for(int i=k+k-1; i>=k; i--)
			if(z[i])
				for(int j=0; j<G.size(); j++)
					z[i-k+G[j]]=(z[i-k+G[j]]
							-z[i]*md[G[j]])%mod;
		for(int i=0; i<k; i++)
			a[i]=z[i];
	}
	int solve(ll n,vector<int> a,vector<int> b)
	{
		ll ans=0,pnt=0;
		int k=a.size();
		for(int i=0; i<k; i++)
			md[k-1-i]=-a[i];
		md[k]=1;
		G.clear();
		for(int i=0; i<k; i++)
			if(md[i]!=0)G.push_back(i);
		for(int i=0; i<k; i++)
			res[i]=base[i]=0;
		res[0]=1;
		while((1ll<<pnt)<=n)pnt++;
		for(int p=pnt; p>=0; p--)
		{
			mul(res,res,k);
			if((n>>p)&1)
			{
				for(int i=k-1; i>=0; i--)
					res[i+1]=res[i];
				res[0]=0;
				for(int j=0; j<G.size(); j++)
					res[G[j]]=(res[G[j]]-res[k]*md[G[j]])%mod;
			}
		}
		for(int i=0; i<k; i++)
			ans=(ans+res[i]*b[i])%mod;
		return (ans+mod)%mod;
	}
	vector<int> BM(vector<int> s)
	{
		vector<int> C(1,1),B(1,1);
		int L=0,m=1,b=1;
		for(int n=0; n<s.size(); n++)
		{
			ll d=0;
			for(int i=0; i<L+1; i++)
				d=(d+(ll)C[i]*s[n-i])%mod;
			if(d==0) ++m;
			else if(2*L<=n)
			{
				vector<int> T=C;
				ll c=mod-d*qpow(b,mod-2)%mod;
				while(C.size()<B.size()+m)
					C.push_back(0);
				for(int i=0; i<B.size(); i++)
					C[i+m]=(C[i+m]+c*B[i])%mod;
				L=n+1-L,B=T,b=d,m=1;
			}
			else
			{
				ll c=mod-d*qpow(b,mod-2)%mod;
				while (C.size()<B.size()+m)
					C.push_back(0);
				for(int i=0; i<B.size(); i++)
					C[i+m]=(C[i+m]+c*B[i])%mod;
				++m;
			}
		}
		return C;
	}
	int gao(vector<int> a,ll n)
	{
		vector<int> c=BM(a);
		c.erase(c.begin());
		for(int i=0; i<c.size(); i++)
			c[i]=(mod-c[i])%mod;
		return solve(n,c,vector<int>
				(a.begin(),a.begin()+c.size()));
	}
};

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		printf("%d\n",xx::gao(vector<int>{2,24,96,416,1536,5504,18944,64000,212992,702464},n-1));
	}
}

```

